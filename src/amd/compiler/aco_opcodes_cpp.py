
template = """\
/*
 * Copyright (c) 2018 Valve Corporation
 *
 * SPDX-License-Identifier: MIT
 *
 * This file was generated by aco_opcodes_cpp.py
 */

#include "aco_ir.h"

namespace aco {

<%
opcode_names = sorted(instructions.keys())
is_atomic = "".join([instructions[name].is_atomic for name in reversed(opcode_names)])
%>

extern const aco::Info instr_info = {
   {
      % for name in opcode_names:
      ${instructions[name].op.gfx7},
      % endfor
   },
   {
      % for name in opcode_names:
      ${instructions[name].op.gfx9},
      % endfor
   },
   {
      % for name in opcode_names:
      ${instructions[name].op.gfx10},
      % endfor
   },
   {
      % for name in opcode_names:
      ${instructions[name].op.gfx11},
      % endfor
   },
   {
      % for name in opcode_names:
      ${instructions[name].op.gfx12},
      % endfor
   },
   std::bitset<${len(opcode_names)}>("${is_atomic}"),
   {
      % for name in opcode_names:
      "${name}",
      % endfor
   },
   {
      % for name in opcode_names:
      aco::Format::${str(instructions[name].format.name)},
      % endfor
   },
   {
      % for name in opcode_names:
      instr_class::${instructions[name].cls.value},
      % endfor
   },
   {
      % for name in opcode_names:
      {
         % for definition in instructions[name].definitions:
         {
            ${definition.alu_type.name},
            ${definition.bitsize},
            ${definition.components},
            ${int(definition.fixed_reg is not None)},
            ${definition.fixed_reg if definition.fixed_reg is not None else "PhysReg{0}"},
            ${int(definition.mods)},
         },
         % endfor
      },
      % endfor
   },
   {
      % for name in opcode_names:
      {
         % for operand in instructions[name].operands:
         {
            ${operand.alu_type.name},
            ${operand.bitsize},
            ${operand.components},
            ${int(operand.fixed_reg is not None)},
            ${operand.fixed_reg if operand.fixed_reg is not None else "PhysReg{0}"},
            ${int(operand.mods)},
         },
         % endfor
      },
      % endfor
   },
   {
      % for (opcode, info) in mimg_opcodes:
      {aco_opcode::${opcode}, (aco_mimg_op_info)${info}},
      % endfor
   },
   {
      % for (opcode, info) in mimg_opcodes:
      {(aco_mimg_op_info)${info}, aco_opcode::${opcode}},
      % endfor
   },
};

}
"""

from aco_opcodes import instructions, mimg_opcodes
from mako.template import Template

print(Template(template).render(instructions=instructions, mimg_opcodes=mimg_opcodes))
